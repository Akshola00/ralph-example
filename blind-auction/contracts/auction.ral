struct Bid {
  blindedBid: ByteVec,
  deposit: U256
}

Contract Auction(
  beneficiary: Address,
  biddingEnd: U256,
  revealEnd: U256,
  mut ended: Bool,
  mut highestBidder: Address,
  mut highestBid: U256,
  mut bids: Map[ByteVec, Bid],
  mut bidNum: Map[Address, U256],
  mut pendingReturns: Map[Address, U256]
) {

  event AuctionEnded(winner: Address, amount: U256)

  enum ErrorCodes {
    InvalidArg = 0
    BiddingAlreadyEnded = 1
    InvalidBidderAddress = 2
    BiddingNotEnd = 3
    RevealAlreadyEnded = 4
    RevealNotEnd = 5
    AuctionEndAlreadyCalled = 6
  }

  @using(preapprovedAssets = true, assetsInContract = true, checkExternalCaller = false)
  pub fn bid(bidder: Address, blindedBid: ByteVec, deposit: U256) -> () {
    assert!(size!(blindedBid) == 32, ErrorCodes.InvalidArg)
    assert!(blockTimeStamp!() <= biddingEnd, ErrorCodes.BiddingAlreadyEnded)
    assert!(isAssetAddress!(bidder), ErrorCodes.InvalidBidderAddress)

    let mut count = 0
    if (!bidNum.contains!(bidder)) {
      bidNum.insert!{bidder -> ALPH: minimalContractDeposit!()}(bidder, 0)
    } else {
      count = bidNum[bidder]
    }

    let bidKey = toByteVec!(bidder) ++ toByteVec!(count)
    let newBid = Bid { blindedBid: blindedBid, deposit: deposit }
    bids.insert!{bidder -> ALPH: minimalContractDeposit!()}(bidKey, newBid)
    bidNum[bidder] = count + 1
    transferTokenToSelf!(bidder, ALPH, deposit)
  }

  @using(preapprovedAssets = true, assetsInContract = true, checkExternalCaller = false)
  pub fn reveal(bidder: Address, values: ByteVec, fakes: ByteVec, secrets: ByteVec) -> () {
    assert!(blockTimeStamp!() > biddingEnd, ErrorCodes.BiddingNotEnd)
    assert!(blockTimeStamp!() <= revealEnd, ErrorCodes.RevealAlreadyEnded)

    let length = bidNum[bidder]
    assert!(size!(values) / 32 == length, ErrorCodes.InvalidArg)
    assert!(size!(fakes) == length, ErrorCodes.InvalidArg)
    assert!(size!(secrets) / 32 == length, ErrorCodes.InvalidArg)

    let mut refund = 0
    let mut remains = length
    for (let mut index = 0; index < length; index = index + 1) {
      let bidKey = toByteVec!(bidder) ++ toByteVec!(index)
      if (bids.contains!(bidKey)) {
        let value = u256From32Byte!(byteVecSlice!(values, index * 32, (index + 1) * 32))
        let fakeByte = byteVecSlice!(fakes, index, index + 1)
        let fake = if (fakeByte == #00) false else true
        let secret = byteVecSlice!(secrets, index * 32, (index + 1) * 32)

        let bidToCheck = bids[bidKey]
        if (bidToCheck.blindedBid == blake2b!(u256To32Byte!(value) ++ toByteVec!(fake) ++ secret)) {
          refund = refund + bidToCheck.deposit

          if (!fake && bidToCheck.deposit >= value && value > highestBid) {
            if (!pendingReturns.contains!(bidder)) {
              pendingReturns.insert!{bidder -> ALPH: minimalContractDeposit!()}(bidder, 0)
            }

            placeBid(bidder, value)
            refund = refund - value
          }
          bids.remove!(bidKey, bidder)
          remains = remains - 1
        }

      } else {
        remains = remains - 1
      }
    }
    transferTokenFromSelf!(bidder, ALPH, refund)
    if (remains == 0) {
      bidNum.remove!(bidder, bidder)
    }
  }

  @using(assetsInContract = true, checkExternalCaller = false)
  pub fn withdraw(bidder: Address) -> () {
    let amount = pendingReturns[bidder]
    if (amount > 0) {
      pendingReturns.remove!(bidder, bidder)
      transferTokenFromSelf!(bidder, ALPH, amount)
    }
  }

  @using(assetsInContract = true, checkExternalCaller = false, updateFields = true)
  pub fn auctionEnd() -> () {
    assert!(blockTimeStamp!() > revealEnd, ErrorCodes.RevealNotEnd)
    assert!(!ended, ErrorCodes.AuctionEndAlreadyCalled)

    emit AuctionEnded(highestBidder, highestBid)
    ended = true
    transferTokenFromSelf!(beneficiary, ALPH, highestBid)
  }

  @using(updateFields = true)
  fn placeBid(bidder: Address, value: U256) -> () {
    if (highestBidder != nullContractAddress!()) {
      // Refund the previously highest bidder.
      pendingReturns[highestBidder] = pendingReturns[highestBidder] + highestBid
    }
    highestBid = value
    highestBidder = bidder
  }

  pub fn getBidNum(bidder: Address) -> U256 {
    return if (bidNum.contains!(bidder)) bidNum[bidder] else 0
  }

  pub fn getBid(bidder: Address, index: U256) -> Bid {
    let bidKey = toByteVec!(bidder) ++ toByteVec!(index)
    return bids[bidKey]
  }

  pub fn getPendingReturn(bidder: Address) -> U256 {
    return pendingReturns[bidder]
  }
}
